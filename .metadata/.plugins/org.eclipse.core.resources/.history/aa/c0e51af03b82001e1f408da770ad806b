/*
 * imu.c
 *
 *  Created on: Nov 13, 2023
 *      Author: les_victor
 */
#include "imu.h"

uint8_t receive_buffer = 0;
uint8_t transmit_buffer = 0x80;

printf("\r\n===== ADXL345 =====\r\n");
printf("Connecter VCC sur le 5V et GND sur GND\r\n");
printf("CS sur D3, SDO sur D12, SDA sur D11, SCL sur D13, INT1 sur D4\r\n");



// Reading the DEVID, it should be 0xE5
HAL_GPIO_WritePin(NSS_GPIO_Port, NSS_Pin, GPIO_PIN_RESET);
HAL_SPI_Transmit(&hspi2, &transmit_buffer, 1, HAL_MAX_DELAY);
HAL_SPI_Receive(&hspi2, &receive_buffer, 1, HAL_MAX_DELAY);
HAL_GPIO_WritePin(NSS_GPIO_Port, NSS_Pin, GPIO_PIN_SET);

printf("DEVID = 0x%02X\r\n", receive_buffer);
if (receive_buffer != 0xE5)
{
	Error_Handler();
}

// Write '1' to the DATA_READY bit in the INT_ENABLE register
// Generate an interrupt when a new data is ready
HAL_GPIO_WritePin(NSS_GPIO_Port, NSS_Pin, GPIO_PIN_RESET);
transmit_buffer = 0x2E;
HAL_SPI_Transmit(&hspi2, &transmit_buffer, 1, HAL_MAX_DELAY);
transmit_buffer = 0x80;
HAL_SPI_Transmit(&hspi2, &transmit_buffer, 1, HAL_MAX_DELAY);
HAL_GPIO_WritePin(NSS_GPIO_Port, NSS_Pin, GPIO_PIN_SET);

// Write '1' to the Measure bit in POWER_CTL register
HAL_GPIO_WritePin(NSS_GPIO_Port, NSS_Pin, GPIO_PIN_RESET);
transmit_buffer = 0x2D;
HAL_SPI_Transmit(&hspi2, &transmit_buffer, 1, HAL_MAX_DELAY);
transmit_buffer = 0x08;
HAL_SPI_Transmit(&hspi2, &transmit_buffer, 1, HAL_MAX_DELAY);
HAL_GPIO_WritePin(NSS_GPIO_Port, NSS_Pin, GPIO_PIN_SET);

uint8_t buffer[6];
int16_t x_int;
int16_t y_int;
int16_t z_int;

float x, y, z;
