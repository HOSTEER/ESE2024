#include "strategy.h"



#define ZONE_MILIEU 0
#define ZONE_DROITE 1
#define ZONE_GAUCHE -1
#define ZONE_HAUTE 1
#define ZONE_BASSE -1


champ_vect_t champ_vect;


void init_champ_vect(void){
	champ_vect.vitesse = 10;
	champ_vect.pt_lim_haut = (500<<16);
	champ_vect.pt_lim_droite = (1000<<16);
	champ_vect.pt_lim_gauche = -1*(1000<<16);
	champ_vect.pt_lim_bas = -1*(500<<16);
	champ_vect.offset_gauche = -1*(10<<16);
	champ_vect.offset_droite = -1*champ_vect.offset_gauche;
	champ_vect.offset_haut = (10<<16);
	champ_vect.offset_bas = -1*champ_vect.offset_haut;
}


int strategy(strat_mode_t * strat_mode, hOdometry_t * hOdometry){

	if((*strat_mode & 0xF000) == HUNTER){
		//Le robot est chasseur
		if((*strat_mode & 0xFF) != NO_OBSTACLE){
			//Obstacle détecté

		}
		else{
			//Aucun obstacle

		}
	}
	else{
		//Le robot est la proie
		if((*strat_mode & 0xFF) != NO_OBSTACLE){
			//Obstacle détecté

		}
		else{
			//Aucun obstacle


		}
	}
	return 0;
}

int champ_vectoriel(strat_mode_t * strat_mode, hOdometry_t * hOdometry){

	return 0;
}

int zone_sorting(champ_vect_t * champ_vect, hOdometry_t * hOdometry){
	int8_t zone_v; //Zone verticale dans laquelle est le robot
	int8_t zone_h; //Zone horizontale dans laquelle est le robot
	if(hOdometry->x >= champ_vect->pt_lim_droite){
		zone_h = ZONE_DROITE;

	}
	else if((hOdometry->x < champ_vect->pt_lim_gauche){
		zone_h = ZONE_GAUCHE;
	}
	else{
		zone_h = ZONE_MILIEU;
	}



	return 0;
}

